# Tenko parser test case

- Path: tests/testcases/labels/param_label_label_func.md

> :: labels
>
> ::> param label label func
>
> Fuzzed
>
> A label propagates its lex names to the parent statement.
>
> However, a function scope root records function names as var and considers the lex names of statements (not decls) to be an empty list, regardless. So label does not propagate up and as a result, the name of a function statement in a label in function root should not clash with its parameters.
>
> This applies to any level of nested labels. No clash. No error.

## Input

`````js
function w(casecase){y:j:function casecase(){}}
`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in five parsing modes: sloppy, sloppy+annexb, strict script, module, module+annexb.

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
throws: Parser error!
  A "labelled function declaration" is only allowed in sloppy web compat mode

start@1:0, error@1:25
╔══╦═════════════════
 1 ║ function w(casecase){y:j:function casecase(){}}
   ║                          ^^^^^^^^------- error
╚══╩═════════════════

`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Sloppy mode with AnnexB

Parsed with script goal with AnnexB rules enabled and as if the code did not start with strict mode header.

`````
ast: {
  type: 'Program',
  loc:{start:{line:1,column:0},end:{line:1,column:47},source:''},
  body: [
    {
      type: 'FunctionDeclaration',
      loc:{start:{line:1,column:0},end:{line:1,column:47},source:''},
      generator: false,
      async: false,
      id: {
        type: 'Identifier',
        loc:{start:{line:1,column:9},end:{line:1,column:10},source:''},
        name: 'w'
      },
      params: [
        {
          type: 'Identifier',
          loc:{start:{line:1,column:11},end:{line:1,column:19},source:''},
          name: 'casecase'
        }
      ],
      body: {
        type: 'BlockStatement',
        loc:{start:{line:1,column:20},end:{line:1,column:47},source:''},
        body: [
          {
            type: 'LabeledStatement',
            loc:{start:{line:1,column:21},end:{line:1,column:46},source:''},
            label: {
              type: 'Identifier',
              loc:{start:{line:1,column:21},end:{line:1,column:22},source:''},
              name: 'y'
            },
            body: {
              type: 'LabeledStatement',
              loc:{start:{line:1,column:23},end:{line:1,column:46},source:''},
              label: {
                type: 'Identifier',
                loc:{start:{line:1,column:23},end:{line:1,column:24},source:''},
                name: 'j'
              },
              body: {
                type: 'FunctionDeclaration',
                loc:{start:{line:1,column:25},end:{line:1,column:46},source:''},
                generator: false,
                async: false,
                id: {
                  type: 'Identifier',
                  loc:{start:{line:1,column:34},end:{line:1,column:42},source:''},
                  name: 'casecase'
                },
                params: [],
                body: {
                  type: 'BlockStatement',
                  loc:{start:{line:1,column:44},end:{line:1,column:46},source:''},
                  body: []
                }
              }
            }
          }
        ]
      }
    }
  ]
}

tokens (18x):
       ID_function IDENT PUNC_PAREN_OPEN IDENT PUNC_PAREN_CLOSE
       PUNC_CURLY_OPEN IDENT PUNC_COLON IDENT PUNC_COLON ID_function
       IDENT PUNC_PAREN_OPEN PUNC_PAREN_CLOSE PUNC_CURLY_OPEN
       PUNC_CURLY_CLOSE PUNC_CURLY_CLOSE
`````

### Module goal with AnnexB

Parsed with the module goal with AnnexB rules enabled.

_Output same as sloppy mode._

## AST Printer

Printer output different from input [sloppy][annexb:yes]:

````js
function w(casecase) {y: j: function casecase() {}}
````

Produces same AST
