# Tenko parser test case

- Path: tests/testcases/error/long_line_in_end.md

> :: error
>
> ::> long line in end
>
> Code frame that doesn't start at the beginning of input
>
> This is a single long line, like you would find in minified files (I know this isn't minified, doesn't matter)

## FAIL

## Input

`````js
function getErrorContext(tokenStart, tokenStop, msg = '', fullErrorContext = false) {  ASSERT(getErrorContext.length >= 2 && getErrorContext.length <= 4, 'arg count');  ASSERT(tokenStart <= tokenStop, 'should have a positive length range', tokenStart, tokenStop);  let inputOffset = 0;  if (!fullErrorContext && tokenStart > 100) inputOffset = tokenStart - 100;  let inputLen = input.length - inputOffset;  if (!fullErrorContext && tokenStop + 100 < input.length) inputLen = (tokenStop + 100) - inputOffset;  let isPointerIncluded = true;  if (inputOffset + inputLen < pointer) {    let len = pointer - inputOffset;    if (len < 1024) {      inputLen = len;    } else {      isPointerIncluded = false;    }  }  let usedInput = input.slice(inputOffset, inputOffset + inputLen);  let tokenOffset = tokenStart - inputOffset;   let nl1 = usedInput.lastIndexOf('\n', tokenOffset);  let nl2 = usedInput.indexOf('\n', nl1 + 1);  if (nl2 < 0) nl2 = usedInput.length;  let arrowCount = (tokenStop - tokenStart) || 1;  let indentCount = tokenOffset - (nl1 + 1);  let pointerLine = currentLine;  let errorLine = currentLine;   let errorColumn = (inputOffset > 0 && nl1 < 0) ? -1 : ((tokenStart - inputOffset) - (nl1 >= 0 ? nl1 + 1 : 0));  if (isPointerIncluded) {    let relativePointer = pointer - inputOffset;    let searchPointer = relativePointer;    while (searchPointer > 0) {      searchPointer = usedInput.lastIndexOf('\n', searchPointer - 1);      --pointerLine;      if (searchPointer > nl1) --errorLine;    }    if (searchPointer !== 0) pointerLine += 1;  }  let maxPointerlineLen = (''+currentLine).length;  let gutterWidth = maxPointerlineLen + 4;   let pre = usedInput.slice(0, nl2).split('\n');  let post = usedInput.slice(nl2 + 1, inputLen).split('\n');  while (pre.length > 1 && pre[0].length === 0) {    pre.shift();    ++pointerLine;  }  while (post.length > 0 && post[post.length - 1].length === 0) {    post.pop();  }  let lc = pointerLine;  let pre2 = pre.map(s => ' ' + ('' + lc++).padStart(maxPointerlineLen, ' ') + ' ║ ' + s.trimRight()).join('\n');  let post2 = post.map(s => ' ' + ('' + lc++).padStart(maxPointerlineLen, ' ') + ' ║ ' + s.trimRight()).join('\n');  if ((''+lc).length > maxPointerlineLen) {    maxPointerlineLen = (''+lc).length;    gutterWidth = maxPointerlineLen + 4;     lc = pointerLine;    pre2 = pre.map(s => ' ' + ('' + lc++).padStart(maxPointerlineLen, ' ') + ' ║ ' + s.trimRight()).join('\n');    post2 = post.map(s => ' ' + ('' + lc++).padStart(maxPointerlineLen, ' ') + ' ║ ' + s.trimRight()).join('\n');  }  let col = pointerLine === 1 ? inputOffset : usedInput.lastIndexOf(inputOffset);  let top = 'start@' + pointerLine + ':' + (col<0?'?':col) + ', error@' + errorLine + ':' + (errorColumn<0?'?':errorColumn) + '\n';  let bar = '═'.repeat(top.length - gutterWidth) + '\n';  let header = '╔' + '═'.repeat(maxPointerlineLen) + '═╦';  let footer = '╚' + '═'.repeat(maxPointerlineLen) + '═╩';  let returnValue = (    top +    header + bar +    pre2 + '\n' +    ' '.repeat(Math.max(0, maxPointerlineLen + 1)) +    ' ║ ' +    ' '.repeat(Math.max(0, indentCount)) +    '^'.repeat(Math.max(0, arrowCount)) +    '------- error' + (msg ? ': ' : '') + msg + (tokenOffset >= usedInput.length ? ' at EOF' : '') + (post2 ? '\n' : '') +    post2 + '\n' +    footer + bar +    ''  );  return returnValue.split('\n').map(s => s.trimRight()).join(fails here) }
`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in five parsing modes: sloppy, sloppy+annexb, strict script, module, module+annexb.

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
throws: Parser error!
  Expecting closing paren `)` for the call, found `here` instead

start@1:3280, error@1:?
╔══╦═══════════════════
 1 ║ n' +    footer + bar +    ''  );  return returnValue.split('\n').map(s => s.trimRight()).join(fails here) }
   ║                                                                                                     ^^^^------- error
╚══╩═══════════════════

`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Sloppy mode with AnnexB

Parsed with script goal with AnnexB rules enabled and as if the code did not start with strict mode header.

_Output same as sloppy mode._

### Module goal with AnnexB

Parsed with the module goal with AnnexB rules enabled.

_Output same as sloppy mode._
