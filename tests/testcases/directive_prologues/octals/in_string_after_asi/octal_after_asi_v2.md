# Tenko parser test case

- Path: tests/testcases/directive_prologues/octals/in_string_after_asi/octal_after_asi_v2.md

> :: directive prologues : octals : in string after asi
>
> ::> octal after asi v2
>
> This tests a nasty case of using octals after the "use strict" directive which has no semi-colon, but rather ASI.
>
> This may only be nasty for Tenko but the problem is that the lexer always scans one token ahead. And before it can consider a string to be a directive it first has to verify that there was a semi or otherwise that it had no tail (member expression, call, etc).
>
> To do this it must scan one token forward, meaning it would consume that token. The problem is that the lexerFlags are still in flux at this point since the current string token may change them.
>
> This test case illustrates this quite clearly: the directive is checked but the next token is already parsed. The directive enables strict mode which means the next token (containing an octal escape) should now trigger an error. Except it was already lexed. So we have to re-validate it.
>
> This check regressed at some point and there was no test like this in place to catch that regression.
>
> Note: this variation has two backslashes, testing whether this is properly handled (ignored)

## PASS

## Input

`````js
function f(){
  "use strict"
  "x\\01"
}
`````

## Output

_Note: the whole output block is auto-generated. Manual changes will be overwritten!_

Below follow outputs in five parsing modes: sloppy, sloppy+annexb, strict script, module, module+annexb.

Note that the output parts are auto-generated by the test runner to reflect actual result.

### Sloppy mode

Parsed with script goal and as if the code did not start with strict mode header.

`````
ast: {
  type: 'Program',
  loc:{start:{line:1,column:0},end:{line:4,column:1},source:''},
  body: [
    {
      type: 'FunctionDeclaration',
      loc:{start:{line:1,column:0},end:{line:4,column:1},source:''},
      generator: false,
      async: false,
      id: {
        type: 'Identifier',
        loc:{start:{line:1,column:9},end:{line:1,column:10},source:''},
        name: 'f'
      },
      params: [],
      body: {
        type: 'BlockStatement',
        loc:{start:{line:1,column:12},end:{line:4,column:1},source:''},
        body: [
          {
            type: 'ExpressionStatement',
            loc:{start:{line:2,column:2},end:{line:2,column:14},source:''},
            expression: {
              type: 'Literal',
              loc:{start:{line:2,column:2},end:{line:2,column:14},source:''},
              value: 'use strict',
              raw: '"use strict"'
            },
            directive: 'use strict'
          },
          {
            type: 'ExpressionStatement',
            loc:{start:{line:3,column:2},end:{line:3,column:9},source:''},
            expression: {
              type: 'Literal',
              loc:{start:{line:3,column:2},end:{line:3,column:9},source:''},
              value: 'x\\01',
              raw: '"x\\\\01"'
            },
            directive: 'x\\\\01'
          }
        ]
      }
    }
  ]
}

tokens (11x):
       ID_function IDENT PUNC_PAREN_OPEN PUNC_PAREN_CLOSE
       PUNC_CURLY_OPEN STRING_DOUBLE ASI STRING_DOUBLE ASI
       PUNC_CURLY_CLOSE
`````

### Strict mode

Parsed with script goal but as if it was starting with `"use strict"` at the top.

_Output same as sloppy mode._

### Module goal

Parsed with the module goal.

_Output same as sloppy mode._

### Sloppy mode with AnnexB

Parsed with script goal with AnnexB rules enabled and as if the code did not start with strict mode header.

_Output same as sloppy mode._

### Module goal with AnnexB

Parsed with the module goal with AnnexB rules enabled.

_Output same as sloppy mode._

## AST Printer

Printer output different from input [sloppy][annexb:no]:

````js
function f() {"use strict";
"x\\01";}
````

Produces same AST
